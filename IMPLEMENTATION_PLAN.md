# HTML 可视化编辑器重构实施计划

本文档基于 PRD.md 将整个重构任务拆分为可单独验证的功能模块，采用模块化开发方法确保功能解耦。

## 开发原则

- 遵循 SOLID 原则，确保每个模块职责单一
- 应用 DRY 原则，避免重复代码
- 采用 KISS 原则，保持简单直观
- 每个功能模块独立可测试
- 单个文件控制在 300 行代码以内
- 完善的 JSDoc 注释

## 阶段一：界面重构模块 (预计 2 周)

### 1. 界面布局重构模块
**状态**: ⏳ 待开始
**目标**: 移除左侧操作栏，重新设计主界面布局
**文件位置**: `src/ui/LayoutManager.ts`, `webview/components/MainLayout.js`

#### 实现功能：
- [ ] 移除现有左侧操作栏组件
- [ ] 重新设计主界面网格布局系统
- [ ] 实现响应式布局适配
- [ ] 添加编辑区域最大化功能

#### 验证标准：
- 编辑区域占用率达到 95% 以上
- 界面响应时间小于 50ms
- 支持最小 1024x768 分辨率

### 2. 底部悬浮工具栏模块
**状态**: ⏳ 待开始
**目标**: 实现底部悬浮工具栏，提供核心操作入口
**文件位置**: `webview/components/FloatingToolbar.js`, `src/ui/ToolbarManager.ts`

#### 实现功能：
- [ ] 创建悬浮工具栏基础组件
- [ ] 实现工具栏按钮组件系统
- [ ] 添加工具栏显示/隐藏动画
- [ ] 实现工具栏状态持久化

#### 工具栏功能按钮：
- 🎯 编辑模式切换
- 👁 预览模式切换
- 🔗 跳转代码位置
- 🔄 刷新视图
- 🔍+ 🔍- 缩放控制
- 📱 设备选择

#### 验证标准：
- 工具栏响应延迟小于 16ms
- 支持键盘导航
- 工具栏状态正确保存

### 3. 工具栏拖拽功能模块
**状态**: ⏳ 待开始
**目标**: 为工具栏添加拖拽移动功能
**文件位置**: `webview/components/DraggableToolbar.js`, `src/interaction/DragManager.ts`

#### 实现功能：
- [ ] 实现工具栏拖拽手柄组件
- [ ] 添加拖拽移动逻辑
- [ ] 实现边界检测和吸附功能
- [ ] 添加拖拽位置记忆功能

#### 验证标准：
- 拖拽操作帧率达到 60fps
- 支持边界吸附和碰撞检测
- 拖拽位置持久化保存

### 4. 设备预览选择器模块
**状态**: ⏳ 待开始
**目标**: 集成响应式设备预览功能到工具栏
**文件位置**: `webview/components/DeviceSelector.js`, `src/preview/DeviceManager.ts`

#### 实现功能：
- [ ] 创建设备预设管理系统
- [ ] 实现设备选择下拉组件
- [ ] 添加自定义尺寸输入功能
- [ ] 实现设备预览模式切换

#### 预设设备：
- iPhone SE (320px)
- iPhone 8 (375px)
- iPhone Plus (414px)
- iPad (768px)
- Laptop (1024px)
- Desktop (1440px)

#### 验证标准：
- 设备切换延迟小于 200ms
- 支持自定义尺寸输入
- 横竖屏切换正常

## 阶段二：Figma 风格操作面板模块 (预计 3 周)

### 5. 元素选择机制模块
**状态**: ⏳ 待开始
**目标**: 实现精确的元素选择和高亮系统
**文件位置**: `src/selection/SelectionManager.ts`, `webview/components/ElementHighlighter.js`

#### 实现功能：
- [ ] 实现元素点击选择逻辑
- [ ] 添加元素高亮边框组件
- [ ] 实现选择状态管理
- [ ] 添加多选支持 (Ctrl+Click)

#### 选择机制：
- 单击选择元素
- 双击进入编辑模式
- Ctrl+Click 多选
- Tab 键顺序选择

#### 验证标准：
- 选择响应时间小于 50ms
- 高亮显示准确无偏移
- 支持嵌套元素选择

### 6. Figma风格操作面板模块
**状态**: ⏳ 待开始
**目标**: 创建跟随元素的悬浮操作面板
**文件位置**: `webview/components/ElementPanel.js`, `src/ui/PanelManager.ts`

#### 实现功能：
- [ ] 创建悬浮面板基础组件
- [ ] 实现面板自适应定位算法
- [ ] 添加面板显示/隐藏动画
- [ ] 实现面板跟随元素移动

#### 面板定位逻辑：
1. 优先显示在元素右侧
2. 空间不足时显示在左侧
3. 垂直空间不足时调整到上方
4. 确保面板完全在视窗内

#### 验证标准：
- 面板显示延迟小于 100ms
- 定位算法准确无遮挡
- 支持多种屏幕尺寸

### 7. 面板标签页模块
**状态**: ⏳ 待开始
**目标**: 实现样式、布局、属性三个功能标签页
**文件位置**: `webview/components/panel/`, `src/ui/panel/`

#### 子模块结构：
```
webview/components/panel/
├── StyleTab.js      // 样式控制标签页
├── LayoutTab.js     // 布局控制标签页
├── AttributeTab.js  // 属性编辑标签页
└── TabManager.js    // 标签页切换管理
```

#### 样式标签页功能：
- [ ] 颜色控制组件（背景、文字、边框）
- [ ] 尺寸控制组件（宽高、边距、内边距）
- [ ] 效果控制组件（圆角、阴影、透明度）

#### 布局标签页功能：
- [ ] 布局模式选择器（流布局/Flex/绝对定位）
- [ ] Flex 属性控制组件
- [ ] 定位属性控制组件

#### 属性标签页功能：
- [ ] HTML 基础属性编辑
- [ ] CSS 类名管理
- [ ] 可访问性属性设置

#### 验证标准：
- 标签页切换流畅无卡顿
- 每个控制组件功能完整
- 实时预览和代码同步

### 8. 颜色和尺寸控制模块
**状态**: ⏳ 待开始
**目标**: 实现直观的颜色选择器和尺寸控制组件
**文件位置**: `webview/components/controls/`, `src/ui/controls/`

#### 实现功能：
- [ ] RGB/HSL/HEX 颜色选择器
- [ ] 色板和预设颜色系统
- [ ] 数值输入框组件
- [ ] 滑动条控制组件
- [ ] 单位选择器 (px, em, rem, %)

#### 验证标准：
- 颜色选择器支持多种格式
- 数值输入支持键盘快捷操作
- 单位转换准确

### 9. 面板自适应定位模块
**状态**: ⏳ 待开始
**目标**: 实现智能的面板定位算法
**文件位置**: `src/ui/PositioningEngine.ts`

#### 实现功能：
- [ ] 元素边界计算算法
- [ ] 视窗空间检测逻辑
- [ ] 多级定位 fallback 策略
- [ ] 面板碰撞检测和避让

#### 定位策略优先级：
1. 元素右侧，垂直居中对齐
2. 元素左侧，垂直居中对齐
3. 元素上方，水平居中对齐
4. 元素下方，水平居中对齐
5. 视窗中央悬浮显示

#### 验证标准：
- 面板永不超出视窗边界
- 多种屏幕尺寸下定位准确
- 缩放状态下定位正确

## 阶段三：简化布局系统模块 (预计 2 周)

### 10. 布局管理器重构模块
**状态**: ⏳ 待开始
**目标**: 重构布局系统，简化为三种核心模式
**文件位置**: `src/layout/LayoutManager.ts`, `src/layout/modes/`

#### 实现功能：
- [ ] 重构 LayoutManager 类架构
- [ ] 实现流布局模式处理器
- [ ] 实现 Flex 布局模式处理器
- [ ] 实现绝对定位模式处理器

#### 布局模式架构：
```typescript
abstract class LayoutMode {
  abstract apply(element: Element, properties: LayoutProperties): void
  abstract remove(element: Element): void
  abstract getProperties(element: Element): LayoutProperties
}

class FlowLayoutMode extends LayoutMode { /* 流布局实现 */ }
class FlexLayoutMode extends LayoutMode { /* Flex布局实现 */ }
class AbsoluteLayoutMode extends LayoutMode { /* 绝对定位实现 */ }
```

#### 验证标准：
- 三种布局模式切换无冲突
- 布局属性正确应用到元素
- 代码同步准确无误

### 11. Flex布局可视化模块
**状态**: ⏳ 待开始
**目标**: 实现 Flex 布局的可视化控制界面
**文件位置**: `webview/components/layout/FlexControls.js`, `src/layout/FlexManager.ts`

#### 实现功能：
- [ ] Flex 方向选择器（row, column, reverse）
- [ ] 主轴对齐控制器（justify-content）
- [ ] 交叉轴对齐控制器（align-items）
- [ ] 换行控制器（flex-wrap）
- [ ] Flex 项目属性控制（flex-grow, flex-shrink）

#### Flex 控制界面：
```
┌─── Flex 容器设置 ───┐
│ 方向: → ↓ ← ↑      │
│ 主轴: ◀─ ─▶ ◆      │
│ 交叉轴: ▲ ▼ ◆      │
│ 换行: □ 允许换行    │
└─────────────────────┘
```

#### 验证标准：
- Flex 属性可视化控制准确
- 实时预览效果正确
- 支持复杂 Flex 布局场景

### 12. 绝对定位自动设置模块
**状态**: ⏳ 待开始
**目标**: 实现绝对定位时父元素的自动相对定位设置
**文件位置**: `src/layout/PositionManager.ts`

#### 实现功能：
- [ ] 父元素定位状态检测
- [ ] 自动添加 `position: relative`
- [ ] 用户确认对话框组件
- [ ] 定位冲突解决逻辑

#### 自动设置流程：
1. 检测元素设置为绝对定位
2. 向上遍历查找定位父元素
3. 如无定位父元素，提示用户
4. 用户确认后自动添加 relative 定位
5. 记录操作以支持撤销

#### 验证标准：
- 父元素定位检测准确
- 用户确认流程友好
- 支持操作撤销恢复

### 13. 布局切换优化模块
**状态**: ⏳ 待开始
**目标**: 优化不同布局模式间的切换体验
**文件位置**: `src/layout/LayoutTransition.ts`

#### 实现功能：
- [ ] 布局切换动画效果
- [ ] 属性冲突检测和清理
- [ ] 布局切换历史记录
- [ ] 切换确认和警告机制

#### 切换逻辑：
- 从流布局到 Flex：保留尺寸属性
- 从 Flex 到绝对定位：保留尺寸，转换位置
- 从绝对定位到流布局：清理定位属性

#### 验证标准：
- 布局切换过渡自然
- 无冲突的 CSS 属性
- 支持切换撤销

## 阶段四：交互增强模块 (预计 2 周)

### 14. 快捷键系统模块
**状态**: ⏳ 待开始
**目标**: 实现完整的键盘快捷操作系统
**文件位置**: `src/keyboard/KeyboardManager.ts`, `src/keyboard/shortcuts/`

#### 实现功能：
- [ ] 快捷键注册和管理系统
- [ ] 基础编辑快捷键（复制、粘贴、删除等）
- [ ] 选择导航快捷键（Tab、Shift+Tab）
- [ ] 布局模式快捷键（Ctrl+1/2/3）
- [ ] 快捷键冲突检测和解决

#### 快捷键映射：
```typescript
const keyboardShortcuts = {
  'Ctrl+C': 'copyElement',
  'Ctrl+V': 'pasteElement',
  'Ctrl+X': 'cutElement',
  'Delete': 'deleteElement',
  'Tab': 'selectNextElement',
  'Shift+Tab': 'selectPreviousElement',
  'Ctrl+1': 'setFlowLayout',
  'Ctrl+2': 'setFlexLayout',
  'Ctrl+3': 'setAbsoluteLayout'
}
```

#### 验证标准：
- 快捷键响应准确率 99%+
- 无 VSCode 原生快捷键冲突
- 支持快捷键自定义配置

### 15. 元素拖拽功能模块
**状态**: ⏳ 待开始
**目标**: 实现直观的元素间拖拽重排功能
**文件位置**: `src/drag/DragDropManager.ts`, `webview/components/DragPreview.js`

#### 实现功能：
- [ ] 拖拽触发器和手柄组件
- [ ] 拖拽状态管理系统
- [ ] 拖拽预览效果
- [ ] 放置目标检测逻辑
- [ ] 嵌套拖拽支持

#### 拖拽操作流程：
1. 鼠标悬停显示拖拽手柄
2. 鼠标按下开始拖拽
3. 移动过程显示半透明预览
4. 检测并高亮放置目标
5. 松开鼠标完成拖拽

#### 验证标准：
- 拖拽操作流畅，60fps+
- 支持复杂嵌套结构拖拽
- 拖拽成功率达到 95%+

### 16. 拖拽预览反馈模块
**状态**: ⏳ 待开始
**目标**: 实现拖拽过程中的视觉预览和反馈
**文件位置**: `webview/components/DragFeedback.js`, `src/drag/FeedbackManager.ts`

#### 实现功能：
- [ ] 拖拽元素半透明预览
- [ ] 放置目标高亮指示器
- [ ] 插入位置指示线
- [ ] 禁止拖拽区域标识
- [ ] 拖拽成功/失败动画反馈

#### 视觉反馈设计：
```
拖拽中的元素：50% 透明度
可放置目标：绿色边框高亮
插入位置：2px 蓝色指示线
禁止区域：红色禁止图标
```

#### 验证标准：
- 预览效果清晰直观
- 反馈响应及时准确
- 支持多种放置模式

### 17. 状态管理优化模块
**状态**: ⏳ 待开始
**目标**: 优化选择和编辑状态的管理机制
**文件位置**: `src/state/StateManager.ts`, `src/state/stores/`

#### 实现功能：
- [ ] 集中式状态管理系统
- [ ] 选择状态持久化
- [ ] 编辑历史记录管理
- [ ] 状态变更监听机制
- [ ] 跨组件状态同步

#### 状态结构：
```typescript
interface EditorState {
  selectedElements: ElementState[]
  editMode: boolean
  currentDevice: DevicePreset
  toolbarPosition: Position
  panelVisible: boolean
  dragState: DragState
  history: HistoryEntry[]
}
```

#### 验证标准：
- 状态同步实时准确
- 历史记录完整可恢复
- 内存占用合理优化

## 阶段五：集成测试模块 (预计 1 周)

### 18. 集成测试模块
**状态**: ⏳ 待开始
**目标**: 全面测试界面响应性和功能完整性
**文件位置**: `tests/integration/`, `tests/e2e/`

#### 测试覆盖范围：
- [ ] 界面响应性能测试
- [ ] 拖拽操作稳定性测试
- [ ] 快捷键功能完整性测试
- [ ] 代码同步准确性测试
- [ ] 多设备预览兼容性测试
- [ ] 内存泄漏和性能测试

#### 性能指标验证：
- 元素选择响应时间 < 50ms
- 拖拽操作帧率 > 60fps
- 工具栏拖拽延迟 < 16ms
- 操作面板显示延迟 < 100ms
- 设备预览切换时间 < 200ms

#### 验证标准：
- 所有性能指标达标
- 功能测试通过率 100%
- 无内存泄漏问题
- 兼容主流分辨率设备

## 开发指导原则

### 代码架构原则
1. **单一职责原则**：每个类和模块只负责一项功能
2. **开闭原则**：对扩展开放，对修改关闭
3. **依赖注入**：通过构造函数注入依赖
4. **接口隔离**：定义最小必要的接口
5. **组合优于继承**：优先使用组合模式

### 代码质量要求
1. **文件大小**：单文件不超过 300 行
2. **函数复杂度**：单函数不超过 20 行
3. **注释覆盖**：所有公共方法必须有 JSDoc
4. **错误处理**：所有异步操作必须有错误处理
5. **类型安全**：TypeScript 严格模式，无 any 类型

### 测试要求
1. **单元测试覆盖率** >= 80%
2. **集成测试**：核心功能必须有集成测试
3. **E2E 测试**：主要用户流程必须有端到端测试
4. **性能测试**：关键操作必须有性能基准测试

## 完成标记说明

每个模块完成后，将在对应的功能项前标记：
- ✅ **已完成**：功能实现完毕，测试通过
- 🚧 **进行中**：正在开发实现
- ⏳ **待开始**：等待开始开发
- ❌ **已阻塞**：遇到问题需要解决

## 风险预警和缓解措施

### 高风险项目
1. **拖拽操作复杂性**
   - 风险：跨元素拖拽的碰撞检测和嵌套逻辑复杂
   - 缓解：建立完整的单元测试，分步实现功能

2. **面板定位算法**
   - 风险：不同屏幕尺寸下的自适应显示
   - 缓解：设计多种 fallback 策略，充分测试

3. **快捷键冲突**
   - 风险：与 VSCode 原生快捷键冲突
   - 缓解：提供自定义配置，建立冲突检测机制

4. **布局自动设置**
   - 风险：自动修改父元素可能影响现有布局
   - 缓解：提供撤销机制和用户确认流程

通过以上模块化设计和详细规划，确保项目能够按阶段稳步推进，每个模块都可以独立开发、测试和验证。